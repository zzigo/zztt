commit ce649d3dac80b29853256d9ee2407f161821b7da
Author: zzigo <lucianoazzigotti@gmail.com>
Date:   Mon Jan 20 15:52:14 2025 +0100

    impros

diff --git a/zztt.git.bfg-report/2025-01-20/15-47-50/cache-stats.txt b/zztt.git.bfg-report/2025-01-20/15-47-50/cache-stats.txt
new file mode 100644
index 0000000..a4f226c
--- /dev/null
+++ b/zztt.git.bfg-report/2025-01-20/15-47-50/cache-stats.txt
@@ -0,0 +1,4 @@
+(apply,CacheStats{hitCount=36, missCount=42, loadSuccessCount=42, loadExceptionCount=0, totalLoadTime=90590295, evictionCount=0})
+(tree,CacheStats{hitCount=131, missCount=108, loadSuccessCount=106, loadExceptionCount=0, totalLoadTime=93988999, evictionCount=0})
+(commit,CacheStats{hitCount=20, missCount=22, loadSuccessCount=22, loadExceptionCount=0, totalLoadTime=47620415, evictionCount=0})
+(tag,CacheStats{hitCount=0, missCount=0, loadSuccessCount=0, loadExceptionCount=0, totalLoadTime=0, evictionCount=0})
diff --git a/zztt.git.bfg-report/2025-01-20/15-47-50/deleted-files.txt b/zztt.git.bfg-report/2025-01-20/15-47-50/deleted-files.txt
new file mode 100644
index 0000000..ecb97b1
--- /dev/null
+++ b/zztt.git.bfg-report/2025-01-20/15-47-50/deleted-files.txt
@@ -0,0 +1,2 @@
+b349cdc7f59080fe1cddf983f886c17ff3197392 1986 deploy.yaml
+979b6df762cb8f0972aaf93a5363576b0c3f94c7 1342 deploy.yaml
diff --git a/zztt.git.bfg-report/2025-01-20/15-47-50/object-id-map.old-new.txt b/zztt.git.bfg-report/2025-01-20/15-47-50/object-id-map.old-new.txt
new file mode 100644
index 0000000..2a1aaf5
--- /dev/null
+++ b/zztt.git.bfg-report/2025-01-20/15-47-50/object-id-map.old-new.txt
@@ -0,0 +1,44 @@
+048a9ed1e425608a1e0506c5fa8e5df387e721a9 f74d895cc1818f34f73fd28b29fb0fa06afcf7b7
+0543b2fd1ea580f520a9ef3a9be2b2296fc80ae3 03bae11b0876be7ac4e3148fe9622259063a587d
+175e6b9c58e6a4aa4660c9a797e8a838046644f8 4b825dc642cb6eb9a060e54bf8d69288fbee4904
+19c262bf5247d7333f3c570026b0ff1abf2427bd 53fba64dd27a07fcae129f898fc778564a103d98
+1df180f011eef7a7e7de53c7cc266198a6481d38 07df5cb4b859ab81796c3606156f208571529fbe
+2632ec33e2460079005c4db6625c3eba0003ab24 6fceeb893677c13c891b48983d3f6f3107b96709
+2a09b52eeae4f5dd32123e97cd5526489d32334b 26e48869baf136f16194a023ed8ae7d90a33cbae
+34f06432329bed379658db24090a5922dc8d709a 4b825dc642cb6eb9a060e54bf8d69288fbee4904
+3d9eae3e2c33f53acaa9bd2fb0bf0aa98e87ec35 4b825dc642cb6eb9a060e54bf8d69288fbee4904
+47cb7683e341d30018b1a91f101a2cb9f75e07e7 0e5f754af9425276bdbdfec2c4a86894706da5af
+4fb7c5b44272b3b5dd961647a76299e72578bf29 682935454c78635a44d88535d293a8598a6112ec
+66aedaaf62b7d2e92689af2e4955906a1d5a9969 33061a14a79fde0acbe249db489f722514720c26
+673bb04ac7ccbed33f4a497408716a7dc8a5719b 5932d1b9fdfc5f43faed45a46752520959e12995
+6983769577357a76357d7c8d6b202263bb0ec30d f5f13ebf58b0244cda73bc73454a21ff972f81cb
+69a1e913d80f614f140c8560562dc35c9ffb2d8f c1b541b2e3eef130913580cf412f0cc7d93dd12f
+6a475c40d20e406fa60853e059f7931fa5de882d 91134c2a520e21ad573b2b76f187077bdd49a630
+6c797cf67e7c966f0a087cfdf86ff6dfc20711bd 0be152eacb81b778a076c37e31ee0ee3409112d8
+7a78fe947addeb9dec1dc708c12e1d06d2dfdc26 43da07d2b1ce698606830bb651912e60186fe168
+7b6f9483d85d92f1ef02dd10c9ab053039ca45d3 9add3338d998f1b0eb99ea2eb21325733dc123f6
+7c85117f66463fded3efb62730c14fba3d1ee743 f67d35f579e0a0fd82b9f06eedb90319446b6760
+7e29783eed827f0bbbf702cbabb6e01721a7f6ef 22b24e861236532e481535f8c9c35161732357e9
+820052ceba9112cf2cbdfb49333e28dc40c1f470 4a683fce8e4bd00fa9c0a198e220e60638f14c49
+844fa5fd7ffb5834dcda6096a55a8352a9cfc33f 40da81027f7a838dabb229a38e368d1d26134444
+86d753f81cb3647228723f8d8b99c69fe5b8795c 86af622177979b493c4952fae4bee0a591083d1c
+86f0f7a53d745f1d4ff0b14d1c1aa143bf8b17c2 bbe5f778e203856f1484f70246761870e3b8e6e5
+989b5c9a704e208739bb2272d7856189ac71edae 4b825dc642cb6eb9a060e54bf8d69288fbee4904
+9a2a7a654afefc60089d242b3d269d6d39935484 cc6db8d1448c46161d1066119993fb90bcdcfc3d
+9c864fd5a067c900823520e5a5f28aafaa65ff0d 8fa8d75f79507ccf740d3f82f7fc5b9f7fb549a7
+ab7410baa54063814c2bd99519025c83a182d6d2 1b07c6e446fbd448dba5d75ec97b5283e606f6c9
+ac573bc28ac76ad4b441f197905c0bab839e493c 9a6061f64c8a5dc547cde30f36dad1d9ec6eca26
+b1625ee372078038a938d8fba555e160194453c0 68824e7ce531780f3b1c053a9597cb9caafcb801
+b455b27c3fe8f910aa88ce3ba3680dad26f656ee 1424858c5a9bd62bca8ae72a9cdb3bf413f35e1b
+bdf6a8c1e3a2bc86b9f203141e237789de7b5621 936022abc3f8792d0f2fd5bcf888237525fb3f3d
+c0d7f458f0e4dfa26bba624e970be5ee42b43a24 2bf65f0eead9aecde91bd9992a38eb0fe9e75e56
+c22965613b1049532bf43f37834a07f36638feb6 451ddbfe5fe51169a54d51b567d053699594a379
+c3a3e02a0efee20ba0609216d4988e0d08c5d011 34238c39c626c6d42fcb8de68f522ac1ed1a2870
+c8568c27dd7b30c49ff46aa69b288eb138927145 a25de477b7139ae11b3c34dbd71bde312c0f66a0
+d0dfd0b3c6db3c205a4ab0031853c66019e0741c bfba896149a93a54900bdc0bcb7fd31ab43e0591
+d113ae5cbfbb6447af0111f1136822dc52d953cb 68d94a24ca43b49ff6113f00d5b73b1941c2bd21
+d5523695a212c342ffd1ffcbb10308926d8becc3 08dc049b8644bede5cc3247bcd7b1e42b6cdd6c0
+ec379090ff772f8235c153cfa969d7c046541e3f 6b9caa409d3cdfd5407699c8ec1483383025de63
+f74403cd0a1b7136a2364fcbae346cbd9ea7d3e9 23711595aab6d21ac253c7996d4afb1e0bd56008
+f9a2d5d0e8703e2caea3d6bf544537b87bad47d9 a3f85cc9041ab4e88653951ae49d1f326d1703df
+fdcbe7b89e870e69d9381ace91f8379370ee14cf aacc5f122d14a06bd0445cae5442f61e990a2835
diff --git a/zztt.git.bfg-report/2025-01-20/15-47-50/protected-dirt/47cb7683-HEAD.csv b/zztt.git.bfg-report/2025-01-20/15-47-50/protected-dirt/47cb7683-HEAD.csv
new file mode 100644
index 0000000..6ee3d56
--- /dev/null
+++ b/zztt.git.bfg-report/2025-01-20/15-47-50/protected-dirt/47cb7683-HEAD.csv
@@ -0,0 +1 @@
+b349cdc7f59080fe1cddf983f886c17ff3197392,DELETE,regular-file,.github/workflows/deploy.yaml,1986,
diff --git a/zztt.git/FETCH_HEAD b/zztt.git/FETCH_HEAD
new file mode 100644
index 0000000..4ddbaaf
--- /dev/null
+++ b/zztt.git/FETCH_HEAD
@@ -0,0 +1,2 @@
+7e29783eed827f0bbbf702cbabb6e01721a7f6ef	not-for-merge	branch 'gh-pages' of https://github.com/zzigo/zztt
+47cb7683e341d30018b1a91f101a2cb9f75e07e7	not-for-merge	branch 'main' of https://github.com/zzigo/zztt
diff --git a/zztt.git/HEAD b/zztt.git/HEAD
new file mode 100644
index 0000000..b870d82
--- /dev/null
+++ b/zztt.git/HEAD
@@ -0,0 +1 @@
+ref: refs/heads/main
diff --git a/zztt.git/config b/zztt.git/config
new file mode 100644
index 0000000..f5e09a0
--- /dev/null
+++ b/zztt.git/config
@@ -0,0 +1,10 @@
+[core]
+	repositoryformatversion = 0
+	filemode = true
+	bare = true
+	ignorecase = true
+	precomposeunicode = true
+[remote "origin"]
+	url = https://github.com/zzigo/zztt.git
+	fetch = +refs/*:refs/*
+	mirror = true
diff --git a/zztt.git/description b/zztt.git/description
new file mode 100644
index 0000000..498b267
--- /dev/null
+++ b/zztt.git/description
@@ -0,0 +1 @@
+Unnamed repository; edit this file 'description' to name the repository.
diff --git a/zztt.git/hooks/applypatch-msg.sample b/zztt.git/hooks/applypatch-msg.sample
new file mode 100755
index 0000000..a5d7b84
--- /dev/null
+++ b/zztt.git/hooks/applypatch-msg.sample
@@ -0,0 +1,15 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message taken by
+# applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.  The hook is
+# allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "applypatch-msg".
+
+. git-sh-setup
+commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
+test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
+:
diff --git a/zztt.git/hooks/commit-msg.sample b/zztt.git/hooks/commit-msg.sample
new file mode 100755
index 0000000..b58d118
--- /dev/null
+++ b/zztt.git/hooks/commit-msg.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to check the commit log message.
+# Called by "git commit" with one argument, the name of the file
+# that has the commit message.  The hook should exit with non-zero
+# status after issuing an appropriate message if it wants to stop the
+# commit.  The hook is allowed to edit the commit message file.
+#
+# To enable this hook, rename this file to "commit-msg".
+
+# Uncomment the below to add a Signed-off-by line to the message.
+# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
+# hook is more suited to it.
+#
+# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
+
+# This example catches duplicate Signed-off-by lines.
+
+test "" = "$(grep '^Signed-off-by: ' "$1" |
+	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
+	echo >&2 Duplicate Signed-off-by lines.
+	exit 1
+}
diff --git a/zztt.git/hooks/fsmonitor-watchman.sample b/zztt.git/hooks/fsmonitor-watchman.sample
new file mode 100755
index 0000000..23e856f
--- /dev/null
+++ b/zztt.git/hooks/fsmonitor-watchman.sample
@@ -0,0 +1,174 @@
+#!/usr/bin/perl
+
+use strict;
+use warnings;
+use IPC::Open2;
+
+# An example hook script to integrate Watchman
+# (https://facebook.github.io/watchman/) with git to speed up detecting
+# new and modified files.
+#
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
+#
+# To enable this hook, rename this file to "query-watchman" and set
+# 'git config core.fsmonitor .git/hooks/query-watchman'
+#
+my ($version, $last_update_token) = @ARGV;
+
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
+
+# Check the hook interface version
+if ($version ne 2) {
+	die "Unsupported query-fsmonitor hook version '$version'.\n" .
+	    "Falling back to scanning...\n";
+}
+
+my $git_work_tree = get_working_dir();
+
+my $retry = 1;
+
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
+launch_watchman();
+
+sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
+
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
+	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
+
+	# In the query expression below we're asking for names of files that
+	# changed since $last_update_token but not from the .git folder.
+	#
+	# To accomplish this, we're using the "since" generator to use the
+	# recency index to select candidate nodes and "fields" to limit the
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	my $last_update_line = "";
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+		$last_update_line = qq[\n"since": $last_update_token,];
+	}
+	my $query = <<"	END";
+		["query", "$git_work_tree", {$last_update_line
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
+		}]
+	END
+
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
+	print CHLD_IN $query;
+	close CHLD_IN;
+	my $response = do {local $/; <CHLD_OUT>};
+
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
+	die "Watchman: command returned no output.\n" .
+	"Falling back to scanning...\n" if $response eq "";
+	die "Watchman: command returned invalid output: $response\n" .
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
+		$retry--;
+		my $response = qx/watchman watch "$git_work_tree"/;
+		die "Failed to make watchman watch '$git_work_tree'.\n" .
+		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
+
+		# Watchman will always return all files on the first query so
+		# return the fast "everything is dirty" flag to git and do the
+		# Watchman query just to get it over with now so we won't pay
+		# the cost in git to look up each individual file.
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
+		eval { launch_watchman() };
+		return 0;
+	}
+
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
+
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
+}
diff --git a/zztt.git/hooks/post-update.sample b/zztt.git/hooks/post-update.sample
new file mode 100755
index 0000000..ec17ec1
--- /dev/null
+++ b/zztt.git/hooks/post-update.sample
@@ -0,0 +1,8 @@
+#!/bin/sh
+#
+# An example hook script to prepare a packed repository for use over
+# dumb transports.
+#
+# To enable this hook, rename this file to "post-update".
+
+exec git update-server-info
diff --git a/zztt.git/hooks/pre-applypatch.sample b/zztt.git/hooks/pre-applypatch.sample
new file mode 100755
index 0000000..4142082
--- /dev/null
+++ b/zztt.git/hooks/pre-applypatch.sample
@@ -0,0 +1,14 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed
+# by applypatch from an e-mail message.
+#
+# The hook should exit with non-zero status after issuing an
+# appropriate message if it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-applypatch".
+
+. git-sh-setup
+precommit="$(git rev-parse --git-path hooks/pre-commit)"
+test -x "$precommit" && exec "$precommit" ${1+"$@"}
+:
diff --git a/zztt.git/hooks/pre-commit.sample b/zztt.git/hooks/pre-commit.sample
new file mode 100755
index 0000000..e144712
--- /dev/null
+++ b/zztt.git/hooks/pre-commit.sample
@@ -0,0 +1,49 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git commit" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message if
+# it wants to stop the commit.
+#
+# To enable this hook, rename this file to "pre-commit".
+
+if git rev-parse --verify HEAD >/dev/null 2>&1
+then
+	against=HEAD
+else
+	# Initial commit: diff against an empty tree object
+	against=$(git hash-object -t tree /dev/null)
+fi
+
+# If you want to allow non-ASCII filenames set this variable to true.
+allownonascii=$(git config --type=bool hooks.allownonascii)
+
+# Redirect output to stderr.
+exec 1>&2
+
+# Cross platform projects tend to avoid non-ASCII filenames; prevent
+# them from being added to the repository. We exploit the fact that the
+# printable range starts at the space character and ends with tilde.
+if [ "$allownonascii" != "true" ] &&
+	# Note that the use of brackets around a tr range is ok here, (it's
+	# even required, for portability to Solaris 10's /usr/bin/tr), since
+	# the square bracket bytes happen to fall in the designated range.
+	test $(git diff --cached --name-only --diff-filter=A -z $against |
+	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
+then
+	cat <<\EOF
+Error: Attempt to add a non-ASCII file name.
+
+This can cause problems if you want to work with people on other platforms.
+
+To be portable it is advisable to rename the file.
+
+If you know what you are doing you can disable this check using:
+
+  git config hooks.allownonascii true
+EOF
+	exit 1
+fi
+
+# If there are whitespace errors, print the offending file names and fail.
+exec git diff-index --check --cached $against --
diff --git a/zztt.git/hooks/pre-merge-commit.sample b/zztt.git/hooks/pre-merge-commit.sample
new file mode 100755
index 0000000..399eab1
--- /dev/null
+++ b/zztt.git/hooks/pre-merge-commit.sample
@@ -0,0 +1,13 @@
+#!/bin/sh
+#
+# An example hook script to verify what is about to be committed.
+# Called by "git merge" with no arguments.  The hook should
+# exit with non-zero status after issuing an appropriate message to
+# stderr if it wants to stop the merge commit.
+#
+# To enable this hook, rename this file to "pre-merge-commit".
+
+. git-sh-setup
+test -x "$GIT_DIR/hooks/pre-commit" &&
+        exec "$GIT_DIR/hooks/pre-commit"
+:
diff --git a/zztt.git/hooks/pre-push.sample b/zztt.git/hooks/pre-push.sample
new file mode 100755
index 0000000..4ce688d
--- /dev/null
+++ b/zztt.git/hooks/pre-push.sample
@@ -0,0 +1,53 @@
+#!/bin/sh
+
+# An example hook script to verify what is about to be pushed.  Called by "git
+# push" after it has checked the remote status, but before anything has been
+# pushed.  If this script exits with a non-zero status nothing will be pushed.
+#
+# This hook is called with the following parameters:
+#
+# $1 -- Name of the remote to which the push is being done
+# $2 -- URL to which the push is being done
+#
+# If pushing without using a named remote those arguments will be equal.
+#
+# Information about the commits which are being pushed is supplied as lines to
+# the standard input in the form:
+#
+#   <local ref> <local oid> <remote ref> <remote oid>
+#
+# This sample shows how to prevent push of commits where the log message starts
+# with "WIP" (work in progress).
+
+remote="$1"
+url="$2"
+
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+
+while read local_ref local_oid remote_ref remote_oid
+do
+	if test "$local_oid" = "$zero"
+	then
+		# Handle delete
+		:
+	else
+		if test "$remote_oid" = "$zero"
+		then
+			# New branch, examine all commits
+			range="$local_oid"
+		else
+			# Update to existing branch, examine new commits
+			range="$remote_oid..$local_oid"
+		fi
+
+		# Check for WIP commit
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
+		then
+			echo >&2 "Found WIP commit in $local_ref, not pushing"
+			exit 1
+		fi
+	fi
+done
+
+exit 0
diff --git a/zztt.git/hooks/pre-rebase.sample b/zztt.git/hooks/pre-rebase.sample
new file mode 100755
index 0000000..6cbef5c
--- /dev/null
+++ b/zztt.git/hooks/pre-rebase.sample
@@ -0,0 +1,169 @@
+#!/bin/sh
+#
+# Copyright (c) 2006, 2008 Junio C Hamano
+#
+# The "pre-rebase" hook is run just before "git rebase" starts doing
+# its job, and can prevent the command from running by exiting with
+# non-zero status.
+#
+# The hook is called with the following parameters:
+#
+# $1 -- the upstream the series was forked from.
+# $2 -- the branch being rebased (or empty when rebasing the current branch).
+#
+# This sample shows how to prevent topic branches that are already
+# merged to 'next' branch from getting rebased, because allowing it
+# would result in rebasing already published history.
+
+publish=next
+basebranch="$1"
+if test "$#" = 2
+then
+	topic="refs/heads/$2"
+else
+	topic=`git symbolic-ref HEAD` ||
+	exit 0 ;# we do not interrupt rebasing detached HEAD
+fi
+
+case "$topic" in
+refs/heads/??/*)
+	;;
+*)
+	exit 0 ;# we do not interrupt others.
+	;;
+esac
+
+# Now we are dealing with a topic branch being rebased
+# on top of master.  Is it OK to rebase it?
+
+# Does the topic really exist?
+git show-ref -q "$topic" || {
+	echo >&2 "No such branch $topic"
+	exit 1
+}
+
+# Is topic fully merged to master?
+not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
+if test -z "$not_in_master"
+then
+	echo >&2 "$topic is fully merged to master; better remove it."
+	exit 1 ;# we could allow it, but there is no point.
+fi
+
+# Is topic ever merged to next?  If so you should not be rebasing it.
+only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
+only_next_2=`git rev-list ^master           ${publish} | sort`
+if test "$only_next_1" = "$only_next_2"
+then
+	not_in_topic=`git rev-list "^$topic" master`
+	if test -z "$not_in_topic"
+	then
+		echo >&2 "$topic is already up to date with master"
+		exit 1 ;# we could allow it, but there is no point.
+	else
+		exit 0
+	fi
+else
+	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
+	/usr/bin/perl -e '
+		my $topic = $ARGV[0];
+		my $msg = "* $topic has commits already merged to public branch:\n";
+		my (%not_in_next) = map {
+			/^([0-9a-f]+) /;
+			($1 => 1);
+		} split(/\n/, $ARGV[1]);
+		for my $elem (map {
+				/^([0-9a-f]+) (.*)$/;
+				[$1 => $2];
+			} split(/\n/, $ARGV[2])) {
+			if (!exists $not_in_next{$elem->[0]}) {
+				if ($msg) {
+					print STDERR $msg;
+					undef $msg;
+				}
+				print STDERR " $elem->[1]\n";
+			}
+		}
+	' "$topic" "$not_in_next" "$not_in_master"
+	exit 1
+fi
+
+<<\DOC_END
+
+This sample hook safeguards topic branches that have been
+published from being rewound.
+
+The workflow assumed here is:
+
+ * Once a topic branch forks from "master", "master" is never
+   merged into it again (either directly or indirectly).
+
+ * Once a topic branch is fully cooked and merged into "master",
+   it is deleted.  If you need to build on top of it to correct
+   earlier mistakes, a new topic branch is created by forking at
+   the tip of the "master".  This is not strictly necessary, but
+   it makes it easier to keep your history simple.
+
+ * Whenever you need to test or publish your changes to topic
+   branches, merge them into "next" branch.
+
+The script, being an example, hardcodes the publish branch name
+to be "next", but it is trivial to make it configurable via
+$GIT_DIR/config mechanism.
+
+With this workflow, you would want to know:
+
+(1) ... if a topic branch has ever been merged to "next".  Young
+    topic branches can have stupid mistakes you would rather
+    clean up before publishing, and things that have not been
+    merged into other branches can be easily rebased without
+    affecting other people.  But once it is published, you would
+    not want to rewind it.
+
+(2) ... if a topic branch has been fully merged to "master".
+    Then you can delete it.  More importantly, you should not
+    build on top of it -- other people may already want to
+    change things related to the topic as patches against your
+    "master", so if you need further changes, it is better to
+    fork the topic (perhaps with the same name) afresh from the
+    tip of "master".
+
+Let's look at this example:
+
+		   o---o---o---o---o---o---o---o---o---o "next"
+		  /       /           /           /
+		 /   a---a---b A     /           /
+		/   /               /           /
+	       /   /   c---c---c---c B         /
+	      /   /   /             \         /
+	     /   /   /   b---b C     \       /
+	    /   /   /   /             \     /
+    ---o---o---o---o---o---o---o---o---o---o---o "master"
+
+
+A, B and C are topic branches.
+
+ * A has one fix since it was merged up to "next".
+
+ * B has finished.  It has been fully merged up to "master" and "next",
+   and is ready to be deleted.
+
+ * C has not merged to "next" at all.
+
+We would want to allow C to be rebased, refuse A, and encourage
+B to be deleted.
+
+To compute (1):
+
+	git rev-list ^master ^topic next
+	git rev-list ^master        next
+
+	if these match, topic has not merged in next at all.
+
+To compute (2):
+
+	git rev-list master..topic
+
+	if this is empty, it is fully merged to "master".
+
+DOC_END
diff --git a/zztt.git/hooks/pre-receive.sample b/zztt.git/hooks/pre-receive.sample
new file mode 100755
index 0000000..a1fd29e
--- /dev/null
+++ b/zztt.git/hooks/pre-receive.sample
@@ -0,0 +1,24 @@
+#!/bin/sh
+#
+# An example hook script to make use of push options.
+# The example simply echoes all push options that start with 'echoback='
+# and rejects all pushes when the "reject" push option is used.
+#
+# To enable this hook, rename this file to "pre-receive".
+
+if test -n "$GIT_PUSH_OPTION_COUNT"
+then
+	i=0
+	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
+	do
+		eval "value=\$GIT_PUSH_OPTION_$i"
+		case "$value" in
+		echoback=*)
+			echo "echo from the pre-receive-hook: ${value#*=}" >&2
+			;;
+		reject)
+			exit 1
+		esac
+		i=$((i + 1))
+	done
+fi
diff --git a/zztt.git/hooks/prepare-commit-msg.sample b/zztt.git/hooks/prepare-commit-msg.sample
new file mode 100755
index 0000000..10fa14c
--- /dev/null
+++ b/zztt.git/hooks/prepare-commit-msg.sample
@@ -0,0 +1,42 @@
+#!/bin/sh
+#
+# An example hook script to prepare the commit log message.
+# Called by "git commit" with the name of the file that has the
+# commit message, followed by the description of the commit
+# message's source.  The hook's purpose is to edit the commit
+# message file.  If the hook fails with a non-zero status,
+# the commit is aborted.
+#
+# To enable this hook, rename this file to "prepare-commit-msg".
+
+# This hook includes three examples. The first one removes the
+# "# Please enter the commit message..." help message.
+#
+# The second includes the output of "git diff --name-status -r"
+# into the message, just before the "git status" output.  It is
+# commented because it doesn't cope with --amend or with squashed
+# commits.
+#
+# The third example adds a Signed-off-by line to the message, that can
+# still be edited.  This is rarely a good idea.
+
+COMMIT_MSG_FILE=$1
+COMMIT_SOURCE=$2
+SHA1=$3
+
+/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
+
+# case "$COMMIT_SOURCE,$SHA1" in
+#  ,|template,)
+#    /usr/bin/perl -i.bak -pe '
+#       print "\n" . `git diff --cached --name-status -r`
+# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
+#  *) ;;
+# esac
+
+# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
+# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
+# if test -z "$COMMIT_SOURCE"
+# then
+#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
+# fi
diff --git a/zztt.git/hooks/push-to-checkout.sample b/zztt.git/hooks/push-to-checkout.sample
new file mode 100755
index 0000000..af5a0c0
--- /dev/null
+++ b/zztt.git/hooks/push-to-checkout.sample
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff --git a/zztt.git/hooks/update.sample b/zztt.git/hooks/update.sample
new file mode 100755
index 0000000..c4d426b
--- /dev/null
+++ b/zztt.git/hooks/update.sample
@@ -0,0 +1,128 @@
+#!/bin/sh
+#
+# An example hook script to block unannotated tags from entering.
+# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
+#
+# To enable this hook, rename this file to "update".
+#
+# Config
+# ------
+# hooks.allowunannotated
+#   This boolean sets whether unannotated tags will be allowed into the
+#   repository.  By default they won't be.
+# hooks.allowdeletetag
+#   This boolean sets whether deleting tags will be allowed in the
+#   repository.  By default they won't be.
+# hooks.allowmodifytag
+#   This boolean sets whether a tag may be modified after creation. By default
+#   it won't be.
+# hooks.allowdeletebranch
+#   This boolean sets whether deleting branches will be allowed in the
+#   repository.  By default they won't be.
+# hooks.denycreatebranch
+#   This boolean sets whether remotely creating branches will be denied
+#   in the repository.  By default this is allowed.
+#
+
+# --- Command line
+refname="$1"
+oldrev="$2"
+newrev="$3"
+
+# --- Safety check
+if [ -z "$GIT_DIR" ]; then
+	echo "Don't run this script from the command line." >&2
+	echo " (if you want, you could supply GIT_DIR then run" >&2
+	echo "  $0 <ref> <oldrev> <newrev>)" >&2
+	exit 1
+fi
+
+if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
+	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
+	exit 1
+fi
+
+# --- Config
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
+
+# check for no description
+projectdesc=$(sed -e '1q' "$GIT_DIR/description")
+case "$projectdesc" in
+"Unnamed repository"* | "")
+	echo "*** Project description file hasn't been set" >&2
+	exit 1
+	;;
+esac
+
+# --- Check types
+# if $newrev is 0000...0000, it's a commit to delete a ref.
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
+if [ "$newrev" = "$zero" ]; then
+	newrev_type=delete
+else
+	newrev_type=$(git cat-file -t $newrev)
+fi
+
+case "$refname","$newrev_type" in
+	refs/tags/*,commit)
+		# un-annotated tag
+		short_refname=${refname##refs/tags/}
+		if [ "$allowunannotated" != "true" ]; then
+			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
+			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,delete)
+		# delete tag
+		if [ "$allowdeletetag" != "true" ]; then
+			echo "*** Deleting a tag is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/tags/*,tag)
+		# annotated tag
+		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
+		then
+			echo "*** Tag '$refname' already exists." >&2
+			echo "*** Modifying a tag is not allowed in this repository." >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,commit)
+		# branch
+		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
+			echo "*** Creating a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/heads/*,delete)
+		# delete branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	refs/remotes/*,commit)
+		# tracking branch
+		;;
+	refs/remotes/*,delete)
+		# delete tracking branch
+		if [ "$allowdeletebranch" != "true" ]; then
+			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
+			exit 1
+		fi
+		;;
+	*)
+		# Anything else (is there anything else?)
+		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
+		exit 1
+		;;
+esac
+
+# --- Finished
+exit 0
diff --git a/zztt.git/info/exclude b/zztt.git/info/exclude
new file mode 100644
index 0000000..a5196d1
--- /dev/null
+++ b/zztt.git/info/exclude
@@ -0,0 +1,6 @@
+# git ls-files --others --exclude-from=.git/info/exclude
+# Lines that start with '#' are comments.
+# For a project mostly in C, the following would be a good set of
+# exclude patterns (uncomment them if you want to use them):
+# *.[oa]
+# *~
diff --git a/zztt.git/info/refs b/zztt.git/info/refs
new file mode 100644
index 0000000..ee99de9
--- /dev/null
+++ b/zztt.git/info/refs
@@ -0,0 +1,2 @@
+7e29783eed827f0bbbf702cbabb6e01721a7f6ef	refs/heads/gh-pages
+47cb7683e341d30018b1a91f101a2cb9f75e07e7	refs/heads/main
diff --git a/zztt.git/objects/info/commit-graph b/zztt.git/objects/info/commit-graph
new file mode 100644
index 0000000..0df5555
Binary files /dev/null and b/zztt.git/objects/info/commit-graph differ
diff --git a/zztt.git/objects/info/packs b/zztt.git/objects/info/packs
new file mode 100644
index 0000000..88a79e1
--- /dev/null
+++ b/zztt.git/objects/info/packs
@@ -0,0 +1,2 @@
+P pack-faa19ce3cbef4da31774a4d92aac280d2258584a.pack
+
diff --git a/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.bitmap b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.bitmap
new file mode 100644
index 0000000..5e4100f
Binary files /dev/null and b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.bitmap differ
diff --git a/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.idx b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.idx
new file mode 100644
index 0000000..9fee964
Binary files /dev/null and b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.idx differ
diff --git a/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.pack b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.pack
new file mode 100644
index 0000000..0526abe
Binary files /dev/null and b/zztt.git/objects/pack/pack-faa19ce3cbef4da31774a4d92aac280d2258584a.pack differ
diff --git a/zztt.git/packed-refs b/zztt.git/packed-refs
new file mode 100644
index 0000000..91f9693
--- /dev/null
+++ b/zztt.git/packed-refs
@@ -0,0 +1,3 @@
+# pack-refs with: peeled fully-peeled sorted 
+7e29783eed827f0bbbf702cbabb6e01721a7f6ef refs/heads/gh-pages
+47cb7683e341d30018b1a91f101a2cb9f75e07e7 refs/heads/main
