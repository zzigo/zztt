---
export const prerender = false;

import { getCollection } from 'astro:content';
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';

const { searchParams } = Astro.url;
const view = searchParams.get('view') || 'chronological';

const isChronological = view === 'chronological';
const isYear = view === 'year';
const isType = view === 'type';

// collections
const works = await getCollection('works');
const events = await getCollection('events');

// helpers
const parseWikilink = (link) =>
  typeof link === 'string' ? link.replace(/\[\[|\]\]/g, '') : '';

// normalize works
const processedWorks = works.map((work) => {
  const performedByArray = Array.isArray(work.data.performedBy)
    ? work.data.performedBy
    : work.data.performedBy
      ? [work.data.performedBy]
      : [];

  let performersDisplay = 'unknown performers';

  if (work.data.listPerformers) {
    performersDisplay = work.data.listPerformers;
  } else if (performedByArray.length > 0) {
    performersDisplay = parseWikilink(performedByArray[0]);
  }

  const workEvents = events.filter((event) => {
    const workTitle = work.data.title.toLowerCase();
    const eventWorks = event.data.work;

    if (Array.isArray(eventWorks)) {
      return eventWorks.some(w => w.toLowerCase() === workTitle);
    }
    if (typeof eventWorks === 'string') {
      return eventWorks.toLowerCase() === workTitle;
    }
    return false;
  });

  const firstPerformanceYear = work.data.pubDate
    ? new Date(work.data.pubDate).getFullYear()
    : null;

  const firstPerformanceEvent =
    workEvents.length > 0 ? workEvents[0].data.venue : null;

  const isUpcoming =
    work.data.pubDate && new Date(work.data.pubDate) > new Date();

  return {
    ...work,
    performersDisplay,
    firstPerformanceYear,
    firstPerformanceEvent,
    isUpcoming,
  };
});

// chronological
const chronologicalWorks = [...processedWorks].sort((a, b) => {
  if (a.firstPerformanceYear && b.firstPerformanceYear) {
    return b.firstPerformanceYear - a.firstPerformanceYear;
  }
  if (a.firstPerformanceYear) return -1;
  if (b.firstPerformanceYear) return 1;
  return a.data.title.localeCompare(b.data.title);
});

// by year
const worksByYear = chronologicalWorks.reduce((acc, work) => {
  const year = work.firstPerformanceYear ?? 'Undated';
  acc[year] ??= [];
  acc[year].push(work);
  return acc;
}, {});

const sortedYears = Object.keys(worksByYear).sort((a, b) => {
  if (a === 'Undated') return 1;
  if (b === 'Undated') return -1;
  return b - a;
});

// by type
const worksByType = processedWorks.reduce((acc, work) => {
  const tags = work.data.tags?.length ? work.data.tags : ['Untagged'];
  tags.forEach(tag => {
    acc[tag] ??= [];
    acc[tag].push(work);
  });
  return acc;
}, {});

const sortedTypes = Object.keys(worksByType).sort();
---
<!doctype html>
<html lang="en">
  <head>
    <BaseHead
      title="List of Works"
      description="Complete list of works by Luciano Azzigotti"
    />

    <style>

      :root {
          --background: #0b0b0b;
          --text: #eaeaea;
          --accent: #ff7a00;
        }
      main {
        max-width: 820px;
        margin: 0 auto;
        padding: 5em 1em;
      }

      h1 {
        font-size: 1.3rem;
        text-align: center;
        margin-bottom: 2em;
        font-weight: normal;
      }

      h2 {
        font-size: 1.1rem;
        margin-top: 1.5em;
        font-weight: normal;
      }

      .view-options {
        text-align: center;
        margin-bottom: 3em;
      }

      .view-options a {
        margin: 0 0.5em;
        padding: 0.4em 0.8em;
        text-decoration: none;
        color: var(--text);
        border-radius: 4px;
      }

      .view-options a.active {
        border: 1px solid var(--accent);
      }

      .works-list {
        list-style: none;
        padding: 1em;
        margin: 0;
      }

      .work-item {
        padding-bottom: 0em;
      }

      .work-line {
        display: inline;
      }

      .work-title {
        color: var(--accent);
        font-weight: 500;
      }

      .work-description {
        opacity: 0.6;
        font-size: 0.8em;
        font-style: italic;
        margin-left: 0.7em;
      }

      .upcoming-label {
        font-size: 0.65em;
        padding: 0.15em 0.45em;
        margin-left: 0.4em;
        background: var(--accent);
        color: var(--background);
        border-radius: 4px;
        letter-spacing: 0.08em;
        vertical-align: middle;
      }

      section[hidden] {
        display: none !important;
      }
    </style>
  </head>

  <body>
    <Header />

    <main>
      <h1>List of Works</h1>

      <nav class="view-options">
        <a href="/list-of-works" class:list={{ active: isChronological }}>
          chronological
        </a>
        <a href="/list-of-works?view=year" class:list={{ active: isYear }}>
          by year
        </a>
        <a href="/list-of-works?view=type" class:list={{ active: isType }}>
          by type
        </a>
      </nav>

      <!-- CHRONOLOGICAL -->
      <section hidden={!isChronological}>
        <ul class="works-list">
          {chronologicalWorks.map(work => (
            <li class="work-item">
              <span class="work-line">
                <span class="work-title">{work.data.title}</span>
                <span class="work-description">
                  {work.data.description}
                </span>
                {work.isUpcoming && (
                  <span class="upcoming-label">Upcoming</span>
                )}
              </span>
              <br />
              <small>
                ({work.firstPerformanceYear ?? 'â€”'}) premiered by {work.performersDisplay}
                at {work.firstPerformanceEvent ?? 'unknown venue'}
                {work.data.tags?.length && (
                  <> <em style="opacity:.3">{work.data.tags.join(', ')}</em></>
                )}
              </small>
            </li>
          ))}
        </ul>
      </section>

      <!-- BY YEAR -->
      <section hidden={!isYear}>
        {sortedYears.map(year => (
          <section>
            <h2>{year}</h2>
            <ul class="works-list">
              {worksByYear[year].map(work => (
                <li class="work-item">
                  <span class="work-line">
                    <span class="work-title">{work.data.title}</span>
                    <span class="work-description">
                    {work.data.description}
                    </span>
                    {work.isUpcoming && (
                      <span class="upcoming-label">Upcoming</span>
                    )}
                  </span>
                </li>
              ))}
            </ul>
          </section>
        ))}
      </section>

      <!-- BY TYPE -->
      <section hidden={!isType}>
        {sortedTypes.map(type => (
          <section>
            <h2>{type}</h2>
            <ul class="works-list">
              {worksByType[type].map(work => (
                <li class="work-item">
                  <span class="work-line">
                    <span class="work-title">{work.data.title}</span>
                    <span class="work-description">
                      {work.data.description}
                    </span>
                    {work.isUpcoming && (
                      <span class="upcoming-label">Upcoming</span>
                    )}
                  </span>
                </li>
              ))}
            </ul>
          </section>
        ))}
      </section>
    </main>

    <Footer />
  </body>
</html>