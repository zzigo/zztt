<div
  id="three-container"
  style="position: absolute; top: 0; left: 0; width: 100%; height: 100vh; z-index: 0; background: linear-gradient(to bottom, #1a0520, #0d0310);"
>
  <button
    id="start-audio-btn"
    style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 15px 30px; background-color: rgba(0, 0, 0, 0.8); color: #fff; border: 2px solid #ff00ff; border-radius: 5px; font-family: monospace; font-size: 18px; cursor: pointer; box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); z-index: 1000; display: none;"
  >
    â—‰ Start Vaporwave Experience
  </button>
</div>

<script>
  import * as THREE from "three";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
  import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
  import * as Tone from "tone";
  import TWEEN from "@tweenjs/tween.js";
  import SphereModule from "./sphereModule.js";
  import CubeModule from "./cubeModule.js";
  import PulseModule from "./pulseModule.js";
  import AudioMixer from "./audioMixer.js";

  // === VAPORWAVE Z-TUNNEL CONFIGURATION ===
  const TUNNEL_CONFIG = {
    zSpeed: 0.7,              // Slow camera Z advancement (was 0.1)
    tunnelLength: 200,         // How far the tunnel extends
    moduleSpawnDistance: 150,  // Spawn modules ahead of camera
    moduleLifetime: 100,       // How long modules live before recycling
    fogNear: 20,              // Fog start distance
    fogFar: 180,              // Fog end distance
    fogColor: 0x1a0520,       // Deep purple fog
  };

  const AUDIO_CONFIG = {
    reverbDecay: 10.0,          // Reverb decay (2 seconds)
    reverbWet: 1,           // 90% reverb mix (extremely wet)
    delayTime: 5.0,           // Delay time (2 seconds)
    delayFeedback: 1,       // Delay feedback (20%)
    delayWet: 0.1,            // 90% delay mix (extremely wet)
    masterVolume: -6,        // Audible volume
    spatialRolloff: 1.,      // Slower spatial falloff
    oscVolume: -35,           // Base oscillator volume
  };

  const VISUAL_CONFIG = {
    bloomStrength: 0.8,       // Reduced bloom (was 1.5)
    bloomRadius: 0.6,         // Larger bloom radius (was 0.4)
    bloomThreshold: 0.7,      // Higher threshold (was 0.85)
    saturation: 1.4,          // More saturation for vaporwave
    brightness: 0.9,          // Slightly darker
  };

  // Initialize Three.js variables
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    0.1,
    500,
  );
  let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  let composer: any;
  let reverb: any;
  let delay: any;
  let listener: any;
  let threeAudioListener: THREE.AudioListener;

  // Initialize modules
  let cubeModule: any;
  let pulseModule: any;
  let sphereModule: any;
  let audioMixer: any;
  let clock = new THREE.Clock();

  // Track audio state
  let toneStarted = false;
  let audioContextReady = false;

  // Z-tunnel state
  let cameraZPosition = 0;
  let modules: any[] = [];
  let moduleIdCounter = 0;

  // God rays shader
  const godRayVertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const godRayFragmentShader = `
    uniform sampler2D tDiffuse;
    uniform vec2 lightPosition;
    uniform float exposure;
    uniform float decay;
    uniform float density;
    uniform float weight;
    uniform int samples;
    varying vec2 vUv;

    void main() {
      vec2 texCoord = vUv;
      vec2 deltaTextCoord = texCoord - lightPosition;
      deltaTextCoord *= 1.0 / float(samples) * density;
      
      vec4 color = texture2D(tDiffuse, texCoord);
      float illuminationDecay = 1.0;
      
      for(int i = 0; i < 100; i++) {
        if(i >= samples) break;
        texCoord -= deltaTextCoord;
        vec4 texSample = texture2D(tDiffuse, texCoord);
        texSample *= illuminationDecay * weight;
        color += texSample;
        illuminationDecay *= decay;
      }
      
      gl_FragColor = color * exposure;
    }
  `;

  // Module creation function - creates audio-visual objects at random positions
  const createModule = (type: 'sphere' | 'cube' | 'pulse') => {
    const module: any = {
      id: moduleIdCounter++,
      type,
      mesh: null,
      audio: null,
      position: new THREE.Vector3(
        (Math.random() - 0.5) * 40,  // X: -20 to 20
        (Math.random() - 0.5) * 30,  // Y: -15 to 15
        cameraZPosition + TUNNEL_CONFIG.moduleSpawnDistance,  // Z: ahead of camera
      ),
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 0.02,  // Slow drift
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.05,
      ),
      rotation: new THREE.Vector3(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
      ),
      rotationSpeed: new THREE.Vector3(
        (Math.random() - 0.5) * 0.003,  // Very slow rotation
        (Math.random() - 0.5) * 0.003,
        (Math.random() - 0.5) * 0.003,
      ),
      scale: 0.5 + Math.random() * 1.0,
      birthZ: cameraZPosition + TUNNEL_CONFIG.moduleSpawnDistance,
    };

    // Create visual mesh based on type
    let geometry, material;
    
    if (type === 'sphere') {
      geometry = new THREE.SphereGeometry(2 * module.scale, 32, 32);
      
      // Vaporwave gradient material
      material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: new THREE.Color(0xff00ff) },
          color2: { value: new THREE.Color(0x00ffff) },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          void main() {
            vPosition = position;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color1;
          uniform vec3 color2;
          varying vec3 vPosition;
          varying vec3 vNormal;
          
          void main() {
            float pattern = sin(vPosition.y * 5.0 + time * 0.3) * 0.5 + 0.5;
            vec3 color = mix(color1, color2, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
            color += fresnel * 0.5;
            gl_FragColor = vec4(color, 0.6);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });
    } else if (type === 'cube') {
      geometry = new THREE.BoxGeometry(3 * module.scale, 3 * module.scale, 3 * module.scale);
      
      material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: new THREE.Color(0xff0099) },
          color2: { value: new THREE.Color(0xffff00) },
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color1;
          uniform vec3 color2;
          varying vec2 vUv;
          varying vec3 vNormal;
          
          void main() {
            // Grid pattern
            float grid = 0.0;
            if (mod(vUv.x * 10.0, 1.0) < 0.1 || mod(vUv.y * 10.0, 1.0) < 0.1) {
              grid = 1.0;
            }
            
            vec3 color = mix(color1, color2, vUv.y);
            color = mix(color, vec3(1.0), grid * 0.5);
            
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
            color += fresnel * 0.7;
            
            gl_FragColor = vec4(color, 0.5);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });
    } else {  // pulse
      geometry = new THREE.TorusGeometry(2 * module.scale, 0.4 * module.scale, 16, 32);
      
      material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(Math.random(), Math.random(), Math.random()),
        transparent: true,
        opacity: 0.4,
        wireframe: true,
      });
    }

    module.mesh = new THREE.Mesh(geometry, material);
    module.mesh.position.copy(module.position);
    module.mesh.rotation.set(module.rotation.x, module.rotation.y, module.rotation.z);
    scene.add(module.mesh);

    // Add point light
    const lightColor = new THREE.Color(
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5
    );
    module.light = new THREE.PointLight(lightColor, 0.8, 30);
    module.light.position.copy(module.position);
    scene.add(module.light);

    // Create spatial audio
    if (audioContextReady && Tone.context.state === "running") {
      try {
        const frequency = 27.5 + Math.random() * 200;  // 27.5-227.5 Hz range (1 octave lower)
        
        // Create oscillator with random waveform
        const waveforms: ('sine' | 'triangle' | 'sawtooth')[] = ['sine', 'triangle', 'sawtooth'];
        const osc = new Tone.Oscillator({
          frequency,
          type: waveforms[Math.floor(Math.random() * waveforms.length)],
          volume: AUDIO_CONFIG.oscVolume,  // Audible volume
        }).start();

        // LFO for subtle modulation
        const lfo = new Tone.LFO({
          frequency: 0.1 + Math.random() * 0.3,
          min: frequency * 0.95,
          max: frequency * 1.05,
        }).start();
        lfo.connect(osc.frequency);

        // Filter with wet control
        const filter = new Tone.Filter({
          type: 'lowpass',
          frequency: 800 + Math.random() * 1200,
          Q: 1,
        });

        // Create wet/dry crossfade for filter
        const filterWet = new Tone.CrossFade(0.8); // 80% wet
        
        // Spatial panner
        const panner = new Tone.Panner3D({
          positionX: module.position.x,
          positionY: module.position.y,
          positionZ: module.position.z,
          rolloffFactor: AUDIO_CONFIG.spatialRolloff,
          distanceModel: 'exponential',
          maxDistance: 10000,
          refDistance: 10,
        });

        // Reliable audio chain: osc -> filter -> panner -> reverb/delay -> destination
        osc.connect(filterWet.a); // dry signal
        osc.connect(filter);
        filter.connect(filterWet.b); // wet signal
        filterWet.connect(panner);
        
        // Connect to reverb and delay if available
        if (reverb && delay) {
          panner.connect(reverb);
          panner.connect(delay);
        } else {
          panner.toDestination();
        }

        module.audio = {
          osc,
          lfo,
          filter,
          filterWet,
          panner,
        };
      } catch (e) {
        console.error('Error creating module audio:', e);
      }
    }

    modules.push(module);
    return module;
  };

  // Update modules in the tunnel
  const updateModules = () => {
    const time = Date.now() * 0.001;

    modules.forEach((module, index) => {
      // Update position
      module.position.x += module.velocity.x;
      module.position.y += module.velocity.y;
      module.position.z += module.velocity.z;

      // Gentle boundaries on X and Y
      if (Math.abs(module.position.x) > 25) {
        module.velocity.x *= -0.9;
      }
      if (Math.abs(module.position.y) > 20) {
        module.velocity.y *= -0.9;
      }

      // Update mesh
      if (module.mesh) {
        module.mesh.position.copy(module.position);
        module.mesh.rotation.x += module.rotationSpeed.x;
        module.mesh.rotation.y += module.rotationSpeed.y;
        module.mesh.rotation.z += module.rotationSpeed.z;

        // Update shader time uniform
        if (module.mesh.material.uniforms && module.mesh.material.uniforms.time) {
          module.mesh.material.uniforms.time.value = time;
        }

        // Pulsing scale
        const pulse = 1.0 + Math.sin(time * 0.5 + module.id) * 0.1;
        module.mesh.scale.setScalar(module.scale * pulse);
      }

      // Update light
      if (module.light) {
        module.light.position.copy(module.position);
        module.light.intensity = 0.5 + Math.sin(time * 0.3 + module.id) * 0.3;
      }

      // Update audio panner position
      if (module.audio && module.audio.panner) {
        module.audio.panner.positionX.value = module.position.x;
        module.audio.panner.positionY.value = module.position.y;
        module.audio.panner.positionZ.value = module.position.z;

        // Fade out audio as module gets behind camera
        const distanceBehind = cameraZPosition - module.position.z;
        if (distanceBehind > 0) {
          const fadeOut = Math.max(0, 1 - distanceBehind / 30);
          module.audio.osc.volume.value = AUDIO_CONFIG.oscVolume + (fadeOut * 15);
        } else {
          // Keep at base volume when ahead
          module.audio.osc.volume.value = AUDIO_CONFIG.oscVolume;
        }
      }

      // Remove modules that are too far behind camera
      if (module.position.z < cameraZPosition - TUNNEL_CONFIG.moduleLifetime) {
        // Cleanup
        if (module.mesh) scene.remove(module.mesh);
        if (module.light) scene.remove(module.light);
        if (module.audio) {
          if (module.audio.osc) module.audio.osc.stop();
          if (module.audio.lfo) module.audio.lfo.stop();
          if (module.audio.osc) module.audio.osc.dispose();
          if (module.audio.lfo) module.audio.lfo.dispose();
          if (module.audio.filter) module.audio.filter.dispose();
          if (module.audio.panner) module.audio.panner.dispose();
        }
        modules.splice(index, 1);
      }
    });

    // Spawn new modules randomly
    if (Math.random() < 0.03) {  // 3% chance per frame
      const types = ['sphere', 'cube', 'pulse'];
      const type = types[Math.floor(Math.random() * types.length)] as any;
      createModule(type);
    }
  };

  // Setup scene
  const setupScene = () => {
    // Renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(TUNNEL_CONFIG.fogColor, 1);

    // Camera starting position
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 100);

    // Fog for depth
    scene.fog = new THREE.Fog(
      TUNNEL_CONFIG.fogColor,
      TUNNEL_CONFIG.fogNear,
      TUNNEL_CONFIG.fogFar
    );

    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x442244, 0.3);
    scene.add(ambientLight);

    // Moving directional light for god rays effect
    const dirLight = new THREE.DirectionalLight(0xff00ff, 0.5);
    dirLight.position.set(10, 10, 50);
    scene.add(dirLight);

    // Add renderer to DOM
    const container = document.getElementById("three-container");
    if (container) {
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      container.appendChild(renderer.domElement);
    }

    // Handle resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  };

  // Setup post-processing with god rays
  const setupPostProcessing = () => {
    composer = new EffectComposer(renderer);

    // Render pass
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // God rays pass
    const godRayShader = {
      uniforms: {
        tDiffuse: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.3 },
        decay: { value: 0.95 },
        density: { value: 0.5 },
        weight: { value: 0.4 },
        samples: { value: 50 },
      },
      vertexShader: godRayVertexShader,
      fragmentShader: godRayFragmentShader,
    };
    const godRayPass = new ShaderPass(godRayShader);
    composer.addPass(godRayPass);

    // Bloom pass
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      VISUAL_CONFIG.bloomStrength,
      VISUAL_CONFIG.bloomRadius,
      VISUAL_CONFIG.bloomThreshold
    );
    composer.addPass(bloomPass);

    // Color correction for vaporwave aesthetic
    const colorCorrectionShader = {
      uniforms: {
        tDiffuse: { value: null },
        saturation: { value: VISUAL_CONFIG.saturation },
        brightness: { value: VISUAL_CONFIG.brightness },
        contrast: { value: 1.1 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float saturation;
        uniform float brightness;
        uniform float contrast;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // Brightness
          color.rgb *= brightness;
          
          // Contrast
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;
          
          // Saturation
          float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(luminance), color.rgb, saturation);
          
          gl_FragColor = color;
        }
      `,
    };

    const colorCorrectionPass = new ShaderPass(colorCorrectionShader);
    composer.addPass(colorCorrectionPass);
  };

  // Setup audio with reverb and delay (extremely wet)
  const setupAudio = async () => {
    try {
      console.log("ðŸŽµ Starting audio setup...");
      
      await Tone.start();
      console.log("âœ“ Tone.js started, context state:", Tone.context.state);

      // Three.js audio listener
      threeAudioListener = new THREE.AudioListener();
      camera.add(threeAudioListener);

      // Create reverb (extremely wet)
      reverb = new Tone.Reverb({
        decay: AUDIO_CONFIG.reverbDecay,
        wet: AUDIO_CONFIG.reverbWet,
      });
      await reverb.generate();
      reverb.toDestination();
      console.log("âœ“ Reverb configured:", AUDIO_CONFIG.reverbDecay + "s decay,", (AUDIO_CONFIG.reverbWet * 100) + "% wet");

      // Create delay (extremely wet)
      delay = new Tone.FeedbackDelay({
        delayTime: AUDIO_CONFIG.delayTime,
        feedback: AUDIO_CONFIG.delayFeedback,
        wet: AUDIO_CONFIG.delayWet,
      });
      delay.toDestination();
      console.log("âœ“ Delay configured:", AUDIO_CONFIG.delayTime + "s time,", (AUDIO_CONFIG.delayFeedback * 100) + "% feedback,", (AUDIO_CONFIG.delayWet * 100) + "% wet");

      // Initialize audio mixer (for additional processing)
      audioMixer = AudioMixer();
      const mixerComponents = audioMixer.init();
      
      // Set master volume
      Tone.getDestination().volume.value = AUDIO_CONFIG.masterVolume;
      console.log("âœ“ Master volume set to:", AUDIO_CONFIG.masterVolume, "dB");

      // Set up listener
      listener = new THREE.AudioListener();
      camera.add(listener);

      audioContextReady = true;
      toneStarted = true;

      console.log("âœ¨ Audio setup complete! Continuous spatial audio modules running...");
      
      return true;
    } catch (error) {
      console.error("âŒ Audio setup error:", error);
      return false;
    }
  };


  // Animation loop
  const animate = () => {
    requestAnimationFrame(animate);

    const deltaTime = clock.getDelta();
    const time = clock.getElapsedTime();

    // CORE Z-TUNNEL EFFECT: Advance camera on Z-axis
    cameraZPosition += TUNNEL_CONFIG.zSpeed;
    camera.position.z = cameraZPosition;

    // Gentle camera wobble for organic feel
    camera.position.x = Math.sin(time * 0.1) * 0.5;
    camera.position.y = Math.cos(time * 0.15) * 0.3;

    // Update modules
    updateModules();

    // Update TWEEN
    TWEEN.update();

    // Render
    if (composer) {
      composer.render();
    } else {
      renderer.render(scene, camera);
    }
  };

  // Initialize everything
  const initialize = async () => {
    try {
      console.log("ðŸŒŠ Initializing Vaporwave Z-Tunnel Experience...");

      setupScene();
      setupPostProcessing();

      // Create initial modules
      for (let i = 0; i < 15; i++) {
        const types = ['sphere', 'cube', 'pulse'];
        const type = types[Math.floor(Math.random() * types.length)] as any;
        createModule(type);
      }

      // Try to start audio automatically or show button
      const startButton = document.getElementById("start-audio-btn");
      
      // Try to auto-start audio if context allows
      try {
        await setupAudio();
        if (startButton) startButton.style.display = "none";
      } catch (e) {
        // If auto-start fails, show button
        console.log("Auto-start failed, showing button");
        if (startButton) {
          startButton.style.display = "block";
          startButton.addEventListener("click", async () => {
            await setupAudio();
            startButton.style.display = "none";
          });
        }
      }

      // Start animation
      animate();

      console.log("âœ¨ Z-Tunnel initialized successfully");
      return true;
    } catch (error) {
      console.error("Error initializing:", error);
      return false;
    }
  };

  // Start on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initialize);
  } else {
    initialize();
  }

  // Auto-start audio on user interaction
  ["click", "touchstart", "keydown"].forEach((eventType) => {
    document.addEventListener(eventType, async () => {
      if (!audioContextReady && !toneStarted) {
        await setupAudio();
        const startButton = document.getElementById("start-audio-btn");
        if (startButton) {
          startButton.style.display = "none";
        }
      }
    }, { once: true });
  });

  // Listen for scroll-based volume changes
  window.addEventListener("scrollVolumeChange", (event: any) => {
    if (audioContextReady && Tone.getDestination()) {
      const volumeFactor = event.detail.volumeFactor;
      
      // Convert volumeFactor (0.0 to 1.0) to dB scale
      // volumeFactor 1.0 -> AUDIO_CONFIG.masterVolume (-12dB)
      // volumeFactor 0.0 -> -Infinity dB (silent)
      let targetVolume;
      if (volumeFactor <= 0.001) {
        // Essentially silent
        targetVolume = -100;
      } else {
        // Logarithmic scaling feels more natural for volume
        // Convert linear 0-1 to dB: 20 * log10(volumeFactor)
        const dbChange = 20 * Math.log10(volumeFactor);
        targetVolume = AUDIO_CONFIG.masterVolume + dbChange;
      }
      
      // Smooth volume transition
      Tone.getDestination().volume.rampTo(targetVolume, 0.1);
      
      // Debug log (uncomment if needed)
      // console.log(`Scroll volume: ${volumeFactor.toFixed(2)} -> ${targetVolume.toFixed(1)}dB`);
    }
  });
</script>
