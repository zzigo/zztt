<div
  id="three-container"
  style="position: absolute; top: 0; left: 0; width: 100%; height: 100vh; z-index: 0; background: linear-gradient(to bottom, #1a0520, #0d0310);"
>
  <button
    id="start-audio-btn"
    style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 15px 30px; background-color: rgba(0, 0, 0, 0.8); color: #fff; border: 2px solid #ff00ff; border-radius: 5px; font-family: monospace; font-size: 13px; cursor: pointer; box-shadow: 0 0 20px rgba(255, 0, 255, 0.5); z-index: 1000; display: none;"
  >
    â—‰ Start Vaporwave Experience
  </button>
</div>

<script>
  import * as THREE from "three";
  import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
  import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
  import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
  import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
  import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
  import * as Tone from "tone";
  import TWEEN from "@tweenjs/tween.js";
  import SphereModule from "./sphereModule.js";
  import CubeModule from "./cubeModule.js";
  import PulseModule from "./pulseModule.js";
  import AudioMixer from "./audioMixer.js";

  // === VAPORWAVE Z-TUNNEL CONFIGURATION ===
  const TUNNEL_CONFIG = {
    zSpeed: 0.5,              // Slow camera Z advancement (was 0.1)
    tunnelLength: 200,         // How far the tunnel extends
    moduleSpawnDistance: 150,  // Spawn modules ahead of camera
    moduleLifetime: 100,       // How long modules live before recycling
    fogNear: 20,              // Fog start distance
    fogFar: 180,              // Fog end distance
    fogColor: 0x1a0520,       // Deep purple fog
  };

  const AUDIO_CONFIG = {
    reverbDecay: 10.0,          // Reverb decay (2 seconds)
    reverbWet: 0.5,           // 50% reverb mix
    delayTime: 0.7,           // Delay time
    delayFeedback: 0.8,       // Delay feedback
    delayWet: 0.5,            // 10% delay mix
    masterVolume: -6,        // Audible volume
    spatialRolloff: 1.,      // Slower spatial falloff
    oscVolume: -15,           // Base oscillator volume
  };

  const VISUAL_CONFIG = {
    bloomStrength: 1,       // Reduced bloom (was 1.5)
    bloomRadius: 0.9,         // Larger bloom radius (was 0.4)
    bloomThreshold: 0.9,      // Higher threshold (was 0.85)
    saturation: 2,          // More saturation for vaporwave
    brightness: 0.2,          // Slightly darker
  };

  // Initialize Three.js variables
  let scene = new THREE.Scene();
  let camera = new THREE.PerspectiveCamera(
    70,
    window.innerWidth / window.innerHeight,
    0.1,
    500,
  );
  let renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  let composer: any;
  let reverb: any;
  let delay: any;
  let listener: any;
  let threeAudioListener: THREE.AudioListener;
  let gltfLoader = new GLTFLoader();
  let singerModel: THREE.Group | null = null;
  let singerAnimations: any[] = [];

  // Initialize modules
  let cubeModule: any;
  let pulseModule: any;
  let sphereModule: any;
  let audioMixer: any;
  let clock = new THREE.Clock();

  // Track audio state
  let toneStarted = false;
  let audioContextReady = false;

  // Z-tunnel state
  let cameraZPosition = 0;
  let modules: any[] = [];
  let moduleIdCounter = 0;
  let nextSingerSpawnTime = 0;

  // Camera orientation controls with inertial physics
  let cameraRotationX = 0; // Up/Down look
  let cameraRotationY = 0; // Left/Right look
  let rotationVelocityX = 0; // Velocity for vertical rotation
  let rotationVelocityY = 0; // Velocity for horizontal rotation
  const rotationAcceleration = 0.0003; // Very subtle acceleration
  const rotationDamping = 0.95; // Drag/friction (0.95 = 5% loss per frame)
  const maxRotationVelocity = 0.005; // Cap maximum rotation speed
  const keyState: { [key: string]: boolean } = {};

  // God rays shader
  const godRayVertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const godRayFragmentShader = `
    uniform sampler2D tDiffuse;
    uniform vec2 lightPosition;
    uniform float exposure;
    uniform float decay;
    uniform float density;
    uniform float weight;
    uniform int samples;
    varying vec2 vUv;

    void main() {
      vec2 texCoord = vUv;
      vec2 deltaTextCoord = texCoord - lightPosition;
      deltaTextCoord *= 1.0 / float(samples) * density;
      
      vec4 color = texture2D(tDiffuse, texCoord);
      float illuminationDecay = 1.0;
      
      for(int i = 0; i < 100; i++) {
        if(i >= samples) break;
        texCoord -= deltaTextCoord;
        vec4 texSample = texture2D(tDiffuse, texCoord);
        texSample *= illuminationDecay * weight;
        color += texSample;
        illuminationDecay *= decay;
      }
      
      gl_FragColor = color * exposure;
    }
  `;

  // Module creation function - creates audio-visual objects at random positions
  const createModule = (type: 'sphere' | 'cube' | 'pulse' | 'singer') => {

    const module: any = {
      id: moduleIdCounter++,
      type,
      mesh: null,
      audio: null,
      position: new THREE.Vector3(
        (Math.random() - 0.5) * 40,  // X: -20 to 20
        (Math.random() - 0.5) * 30,  // Y: -15 to 15
        cameraZPosition + TUNNEL_CONFIG.moduleSpawnDistance,  // Z: ahead of camera
      ),
      velocity: new THREE.Vector3(
        (Math.random() - 0.5) * 0.02,  // Slow drift
        (Math.random() - 0.5) * 0.02,
        (Math.random() - 0.5) * 0.05,
      ),
      rotation: new THREE.Vector3(
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
        Math.random() * Math.PI * 2,
      ),
      rotationSpeed: new THREE.Vector3(
        (Math.random() - 0.5) * 0.003,  // Very slow rotation
        (Math.random() - 0.5) * 0.003,
        (Math.random() - 0.5) * 0.003,
      ),
      scale: 0.5 + Math.random() * 1.0,
      birthZ: cameraZPosition + TUNNEL_CONFIG.moduleSpawnDistance,
    };

    // Override for Singer to make it a "Chaser"
    if (type === 'singer') {
      module.position.set(
        (Math.random() - 0.5) * 20, // Wider X range for variety
        (Math.random() - 0.5) * 10, // Wider Y range
        cameraZPosition - 60 // Start well behind the camera
      );
      // Move faster than camera (zSpeed is 0.5)
      module.velocity.set(
        (Math.random() - 0.5) * 0.01,
        (Math.random() - 0.5) * 0.01,
        TUNNEL_CONFIG.zSpeed + 0.04 // Consistent slow overtake speed
      );
      // Rotate slowly in XYZ
      module.rotationSpeed.set(
        (Math.random() - 0.5) * 0.01,
        (Math.random() - 0.5) * 0.01,
        (Math.random() - 0.5) * 0.01
      );
      module.scale = 1.5;
      
      // Placeholder for future TTS capability
      // Ideally, this logic should be moved to a separate SingerModule.js file
      module.speak = (text) => {
        console.log("Singer says:", text);
        // Future: Implement Web Speech API here and map to morph targets
      };
    }

    // Create visual mesh based on type
    let geometry, material;
    
    if (type === 'sphere') {
      geometry = new THREE.SphereGeometry(2 * module.scale, 32, 32);
      
      // Vaporwave gradient material
      material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: new THREE.Color(0xff00ff) },
          color2: { value: new THREE.Color(0x00ffff) },
        },
        vertexShader: `
          varying vec3 vPosition;
          varying vec3 vNormal;
          void main() {
            vPosition = position;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color1;
          uniform vec3 color2;
          varying vec3 vPosition;
          varying vec3 vNormal;
          
          void main() {
            float pattern = sin(vPosition.y * 5.0 + time * 0.3) * 0.5 + 0.5;
            vec3 color = mix(color1, color2, pattern);
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 2.0);
            color += fresnel * 0.5;
            gl_FragColor = vec4(color, 0.6);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });
    } else if (type === 'cube') {
      geometry = new THREE.BoxGeometry(3 * module.scale, 3 * module.scale, 3 * module.scale);
      
      material = new THREE.ShaderMaterial({
        uniforms: {
          time: { value: 0 },
          color1: { value: new THREE.Color(0xff0099) },
          color2: { value: new THREE.Color(0xffff00) },
        },
        vertexShader: `
          varying vec2 vUv;
          varying vec3 vNormal;
          void main() {
            vUv = uv;
            vNormal = normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          uniform float time;
          uniform vec3 color1;
          uniform vec3 color2;
          varying vec2 vUv;
          varying vec3 vNormal;
          
          void main() {
            // Grid pattern
            float grid = 0.0;
            if (mod(vUv.x * 10.0, 1.0) < 0.1 || mod(vUv.y * 10.0, 1.0) < 0.1) {
              grid = 1.0;
            }
            
            vec3 color = mix(color1, color2, vUv.y);
            color = mix(color, vec3(1.0), grid * 0.5);
            
            float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0, 0, 1))), 3.0);
            color += fresnel * 0.7;
            
            gl_FragColor = vec4(color, 0.5);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        side: THREE.DoubleSide,
      });
    } else if (type === 'singer') {
      if (singerModel) {
        module.mesh = singerModel.clone();
        
        // Apply wireframe material
        module.mesh.traverse((child: any) => {
          if (child.isMesh) {
            child.material = new THREE.MeshStandardMaterial({
              color: 0xffccaa,
              wireframe: true,
              emissive: 0x331111,
            });
          }
        });

        // Apply scale to the cloned group/mesh
        module.scale *= 2.0; // Make singer bigger
        module.mesh.scale.setScalar(module.scale);

        // Setup animation mixer
        if (singerAnimations && singerAnimations.length > 0) {
          module.mixer = new THREE.AnimationMixer(module.mesh);
          // Play the first animation found
          module.mixer.clipAction(singerAnimations[0]).play();
        }
      } else {
        // Fallback Placeholder
        geometry = new THREE.IcosahedronGeometry(2.5 * module.scale, 1);
        material = new THREE.MeshStandardMaterial({
          color: 0xffccaa,
          roughness: 0.4,
          metalness: 0.1,
          emissive: 0x331111,
          flatShading: true,
        });
      }
    } else {  // pulse
      geometry = new THREE.TorusGeometry(2 * module.scale, 0.4 * module.scale, 16, 32);
      
      material = new THREE.MeshBasicMaterial({
        color: new THREE.Color(Math.random(), Math.random(), Math.random()),
        transparent: true,
        opacity: 0.4,
        wireframe: true,
      });
    }

    // If mesh wasn't created via clone() (i.e. it's a primitive), create it now
    if (!module.mesh) {
      module.mesh = new THREE.Mesh(geometry, material);
    }
    module.mesh.position.copy(module.position);
    module.mesh.rotation.set(module.rotation.x, module.rotation.y, module.rotation.z);
    scene.add(module.mesh);

    // Add point light
    const lightColor = new THREE.Color(
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5,
      0.5 + Math.random() * 0.5
    );
    module.light = new THREE.PointLight(lightColor, 0.8, 30);
    module.light.position.copy(module.position);
    scene.add(module.light);

    // Create spatial audio
    if (audioContextReady && Tone.context.state === "running") {
      try {
        const frequency = 27.5 + Math.random() * 200;  // 27.5-227.5 Hz range (1 octave lower)
        
        // Create oscillator with random waveform
        const waveforms: ('sine' | 'triangle' | 'sawtooth')[] = ['sine', 'triangle', 'sawtooth'];
        const osc = new Tone.Oscillator({
          frequency,
          type: waveforms[Math.floor(Math.random() * waveforms.length)],
          volume: AUDIO_CONFIG.oscVolume,  // Audible volume
        }).start();

        // LFO for subtle modulation
        const lfo = new Tone.LFO({
          frequency: 0.1 + Math.random() * 0.3,
          min: frequency * 0.95,
          max: frequency * 1.05,
        }).start();
        lfo.connect(osc.frequency);

        // Filter with wet control
        const filter = new Tone.Filter({
          type: 'lowpass',
          frequency: 800 + Math.random() * 1200,
          Q: 1,
        });

        // Create wet/dry crossfade for filter
        const filterWet = new Tone.CrossFade(0.8); // 80% wet
        
        // Spatial panner
        const panner = new Tone.Panner3D({
          positionX: module.position.x,
          positionY: module.position.y,
          positionZ: module.position.z,
          rolloffFactor: AUDIO_CONFIG.spatialRolloff,
          distanceModel: 'exponential',
          maxDistance: 10000,
          refDistance: 10,
        });

        // Reliable audio chain: osc -> filter -> panner -> reverb/delay -> destination
        osc.connect(filterWet.a); // dry signal
        osc.connect(filter);
        filter.connect(filterWet.b); // wet signal
        filterWet.connect(panner);
        
        // Connect to Audio Mixer
        if (audioMixer) {
          const channelMap = {
            'sphere': 'sphereOscillators',
            'cube': 'cubeOscillators',
            'pulse': 'pulseOscillators',
            'singer': 'floatingModelAudio'
          };
          const channel = channelMap[type] || 'sphereOscillators';
          audioMixer.connectNode(panner, channel);
          
          // Also connect to effects (parallel processing)
          if (reverb) panner.connect(reverb);
          if (delay) panner.connect(delay);
        } else {
          panner.toDestination();
        }

        module.audio = {
          osc,
          lfo,
          filter,
          filterWet,
          panner,
        };
      } catch (e) {
        console.error('Error creating module audio:', e);
      }
    }

    modules.push(module);
    return module;
  };

  // Update modules in the tunnel
  const updateModules = (deltaTime: number) => {
    const time = Date.now() * 0.001;

    modules.forEach((module, index) => {
      // Update position
      module.position.x += module.velocity.x;
      module.position.y += module.velocity.y;
      module.position.z += module.velocity.z;

      // Gentle boundaries on X and Y
      if (Math.abs(module.position.x) > 25) {
        module.velocity.x *= -0.9;
      }
      if (Math.abs(module.position.y) > 20) {
        module.velocity.y *= -0.9;
      }

      // Update mesh
      if (module.mesh) {
        module.mesh.position.copy(module.position);
        module.mesh.rotation.x += module.rotationSpeed.x;
        module.mesh.rotation.y += module.rotationSpeed.y;
        module.mesh.rotation.z += module.rotationSpeed.z;

        // Update shader time uniform
        if (module.mesh.material && module.mesh.material.uniforms && module.mesh.material.uniforms.time) {
          module.mesh.material.uniforms.time.value = time;
        }

        // Pulsing scale
        const pulse = 1.0 + Math.sin(time * 0.5 + module.id) * 0.1;
        module.mesh.scale.setScalar(module.scale * pulse);

        // Update animation mixer for singer
        if (module.mixer) {
          module.mixer.update(deltaTime);
        } else if (module.type === 'singer' && module.mesh) {
          // Procedural fallback: try to animate morph targets if available
          module.mesh.traverse((child: any) => {
            if (child.morphTargetInfluences && child.morphTargetInfluences.length > 0) {
              child.morphTargetInfluences[0] = (Math.sin(time * 8) + 1) * 0.5;
            }
          });
        }
      }

      // Update light
      if (module.light) {
        module.light.position.copy(module.position);
        module.light.intensity = 0.5 + Math.sin(time * 0.3 + module.id) * 0.3;
      }

      // Update audio panner position
      if (module.audio && module.audio.panner) {
        module.audio.panner.positionX.value = module.position.x;
        module.audio.panner.positionY.value = module.position.y;
        module.audio.panner.positionZ.value = module.position.z;

        // Fade out audio as module gets behind camera
        const distanceBehind = cameraZPosition - module.position.z;
        if (distanceBehind > 0) {
          const fadeOut = Math.max(0, 1 - distanceBehind / 30);
          module.audio.osc.volume.value = AUDIO_CONFIG.oscVolume + (fadeOut * 15);
        } else {
          // Keep at base volume when ahead
          module.audio.osc.volume.value = AUDIO_CONFIG.oscVolume;
        }
      }

      // Lifecycle Management
      let shouldRemove = false;
      
      // Special case for Singer: Recycle when it goes too far AHEAD (into the fog)
      if (module.type === 'singer') {
        // Wait until it is deep in the fog before recycling
        if (module.position.z > cameraZPosition + TUNNEL_CONFIG.fogFar) { 
          // Reset to behind camera (Eternal Loop)
          module.position.z = cameraZPosition - 60 - Math.random() * 20;
          module.position.x = (Math.random() - 0.5) * 30;
          module.position.y = (Math.random() - 0.5) * 15;
          
          // Randomize trajectory for the next pass
          module.velocity.x = (Math.random() - 0.5) * 0.01;
          module.velocity.y = (Math.random() - 0.5) * 0.01;
          module.velocity.z = TUNNEL_CONFIG.zSpeed + 0.03 + Math.random() * 0.03; // Varying speed

          // Randomize rotation
          module.rotationSpeed.set(
            (Math.random() - 0.5) * 0.01,
            (Math.random() - 0.5) * 0.01,
            (Math.random() - 0.5) * 0.01
          );
          
          // Don't remove, just reset
          shouldRemove = false;
        }
      } 
      // Standard modules: Remove when too far BEHIND
      else if (module.position.z < cameraZPosition - TUNNEL_CONFIG.moduleLifetime) {
        shouldRemove = true;
      }

      if (shouldRemove) {
        // Cleanup
        if (module.mesh) scene.remove(module.mesh);
        if (module.light) scene.remove(module.light);
        if (module.audio) {
          if (module.audio.osc) module.audio.osc.stop();
          if (module.audio.lfo) module.audio.lfo.stop();
          if (module.audio.osc) module.audio.osc.dispose();
          if (module.audio.lfo) module.audio.lfo.dispose();
          if (module.audio.filter) module.audio.filter.dispose();
          if (module.audio.panner) module.audio.panner.dispose();
        }
        modules.splice(index, 1);
      }
    });

    // Spawn new modules randomly
    if (Math.random() < 0.03) {  // 3% chance per frame
      const types = ['sphere', 'cube', 'pulse']; // Don't spawn random singers, we have a persistent one
      const type = types[Math.floor(Math.random() * types.length)] as any;
      createModule(type);
    }
  };

  // Setup scene
  const setupScene = () => {
    // Renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(TUNNEL_CONFIG.fogColor, 1);

    // Camera starting position
    camera.position.set(0, 0, 0);
    camera.lookAt(0, 0, 100);

    // Fog for depth
    scene.fog = new THREE.Fog(
      TUNNEL_CONFIG.fogColor,
      TUNNEL_CONFIG.fogNear,
      TUNNEL_CONFIG.fogFar
    );

    // Ambient light
    const ambientLight = new THREE.AmbientLight(0x442244, 0.3);
    scene.add(ambientLight);

    // Moving directional light for god rays effect
    const dirLight = new THREE.DirectionalLight(0xff00ff, 0.5);
    dirLight.position.set(10, 10, 50);
    scene.add(dirLight);

    // Add renderer to DOM
    const container = document.getElementById("three-container");
    if (container) {
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      container.appendChild(renderer.domElement);
    }

    // Handle resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  };

  // Setup post-processing with god rays
  const setupPostProcessing = () => {
    composer = new EffectComposer(renderer);

    // Render pass
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // God rays pass
    const godRayShader = {
      uniforms: {
        tDiffuse: { value: null },
        lightPosition: { value: new THREE.Vector2(0.5, 0.5) },
        exposure: { value: 0.3 },
        decay: { value: 0.95 },
        density: { value: 0.5 },
        weight: { value: 0.4 },
        samples: { value: 50 },
      },
      vertexShader: godRayVertexShader,
      fragmentShader: godRayFragmentShader,
    };
    const godRayPass = new ShaderPass(godRayShader);
    composer.addPass(godRayPass);

    // Bloom pass
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      VISUAL_CONFIG.bloomStrength,
      VISUAL_CONFIG.bloomRadius,
      VISUAL_CONFIG.bloomThreshold
    );
    composer.addPass(bloomPass);

    // Color correction for vaporwave aesthetic
    const colorCorrectionShader = {
      uniforms: {
        tDiffuse: { value: null },
        saturation: { value: VISUAL_CONFIG.saturation },
        brightness: { value: VISUAL_CONFIG.brightness },
        contrast: { value: 1.1 },
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float saturation;
        uniform float brightness;
        uniform float contrast;
        varying vec2 vUv;
        
        void main() {
          vec4 color = texture2D(tDiffuse, vUv);
          
          // Brightness
          color.rgb *= brightness;
          
          // Contrast
          color.rgb = (color.rgb - 0.5) * contrast + 0.5;
          
          // Saturation
          float luminance = dot(color.rgb, vec3(0.299, 0.587, 0.114));
          color.rgb = mix(vec3(luminance), color.rgb, saturation);
          
          gl_FragColor = color;
        }
      `,
    };

    const colorCorrectionPass = new ShaderPass(colorCorrectionShader);
    composer.addPass(colorCorrectionPass);
  };

  // Setup audio with reverb and delay (extremely wet)
  const setupAudio = async () => {
    try {
      console.log("ðŸŽµ Starting audio setup...");
      
      await Tone.start();
      console.log("âœ“ Tone.js started, context state:", Tone.context.state);

      // Three.js audio listener
      threeAudioListener = new THREE.AudioListener();
      camera.add(threeAudioListener);

      // Initialize audio mixer (for additional processing)
      audioMixer = AudioMixer();
      const mixerComponents = audioMixer.init(AUDIO_CONFIG);
      
      // Use mixer's effect nodes
      reverb = mixerComponents.reverbNode;
      delay = mixerComponents.delayNode;
      
      // Ensure reverb is generated (Tone.Reverb needs this)
      await reverb.generate();
      
      // Set master volume
      Tone.getDestination().volume.value = AUDIO_CONFIG.masterVolume;
      console.log("âœ“ Master volume set to:", AUDIO_CONFIG.masterVolume, "dB");

      // Set up listener
      listener = new THREE.AudioListener();
      camera.add(listener);

      audioContextReady = true;
      toneStarted = true;

      console.log("âœ¨ Audio setup complete! Continuous spatial audio modules running...");
      
      return true;
    } catch (error) {
      console.error("âŒ Audio setup error:", error);
      return false;
    }
  };


  // Animation loop
  const animate = () => {
    requestAnimationFrame(animate);

    const deltaTime = clock.getDelta();
    const time = clock.getElapsedTime();

    // CORE Z-TUNNEL EFFECT: Advance camera on Z-axis
    cameraZPosition += TUNNEL_CONFIG.zSpeed;
    camera.position.z = cameraZPosition;

    // Handle keyboard input with inertial physics
    // Apply acceleration when keys pressed
    if (keyState['ArrowLeft'] || keyState['a'] || keyState['A']) {
      rotationVelocityY += rotationAcceleration;
    }
    if (keyState['ArrowRight'] || keyState['d'] || keyState['D']) {
      rotationVelocityY -= rotationAcceleration;
    }
    if (keyState['ArrowUp'] || keyState['w'] || keyState['W']) {
      rotationVelocityX += rotationAcceleration;
    }
    if (keyState['ArrowDown'] || keyState['s'] || keyState['S']) {
      rotationVelocityX -= rotationAcceleration;
    }

    // Apply damping (drag/friction)
    rotationVelocityX *= rotationDamping;
    rotationVelocityY *= rotationDamping;

    // Clamp velocity to max speed
    rotationVelocityX = Math.max(-maxRotationVelocity, Math.min(maxRotationVelocity, rotationVelocityX));
    rotationVelocityY = Math.max(-maxRotationVelocity, Math.min(maxRotationVelocity, rotationVelocityY));

    // Apply velocity to rotation
    cameraRotationX += rotationVelocityX;
    cameraRotationY += rotationVelocityY;

    // Clamp rotation to prevent extreme angles
    cameraRotationX = Math.max(-Math.PI / 4, Math.min(Math.PI / 4, cameraRotationX));
    cameraRotationY = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, cameraRotationY));

    // Apply rotation to camera
    camera.rotation.x = cameraRotationX;
    camera.rotation.y = cameraRotationY;

    // Gentle camera wobble for organic feel (reduced to not interfere with controls)
    const wobbleX = Math.sin(time * 0.1) * 0.2;
    const wobbleY = Math.cos(time * 0.15) * 0.15;
    camera.position.x = wobbleX;
    camera.position.y = wobbleY;

    // Update modules
    updateModules(deltaTime);

    // Update TWEEN
    TWEEN.update();

    // Render
    if (composer) {
      composer.render();
    } else {
      renderer.render(scene, camera);
    }
  };

  // Initialize everything
  const initialize = async () => {
    try {
      console.log("ðŸŒŠ Initializing Vaporwave Z-Tunnel Experience...");

      setupScene();
      setupPostProcessing();

      // Load Singer Model
      await new Promise((resolve) => {
        gltfLoader.load('/inc/rigged-mouth/source/mouth2.glb', (gltf) => {
          singerModel = gltf.scene;
          singerAnimations = gltf.animations;
          console.log("âœ“ Singer model loaded");
          resolve(null);
        }, undefined, (err) => {
          console.log("Singer model not found (using placeholder)");
          resolve(null); // Resolve anyway to continue
        });
      });

      // Create initial modules
      for (let i = 0; i < 15; i++) {
        const types = ['sphere', 'cube', 'pulse'];
        const type = types[Math.floor(Math.random() * types.length)] as any;
        createModule(type);
      }

      // Explicitly spawn the Singer
      createModule('singer');

      // Try to start audio automatically or show button
      const startButton = document.getElementById("start-audio-btn");
      
      // Try to auto-start audio if context allows
      try {
        await setupAudio();
        if (startButton) startButton.style.display = "none";
      } catch (e) {
        // If auto-start fails, show button
        console.log("Auto-start failed, showing button");
        if (startButton) {
          startButton.style.display = "block";
          startButton.addEventListener("click", async () => {
            await setupAudio();
            startButton.style.display = "none";
          });
        }
      }

      // Start animation
      animate();

      console.log("âœ¨ Z-Tunnel initialized successfully");
      return true;
    } catch (error) {
      console.error("Error initializing:", error);
      return false;
    }
  };

  // Start on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initialize);
  } else {
    initialize();
  }

  // Auto-start audio on user interaction
  ["click", "touchstart", "keydown"].forEach((eventType) => {
    document.addEventListener(eventType, async () => {
      if (!audioContextReady && !toneStarted) {
        await setupAudio();
        const startButton = document.getElementById("start-audio-btn");
        if (startButton) {
          startButton.style.display = "none";
        }
      }
    }, { once: true });
  });

  // Listen for scroll-based volume changes
  window.addEventListener("scrollVolumeChange", (event: any) => {
    if (audioContextReady && Tone.getDestination()) {
      const volumeFactor = event.detail.volumeFactor;
      
      // Convert volumeFactor (0.0 to 1.0) to dB scale
      // volumeFactor 1.0 -> AUDIO_CONFIG.masterVolume (-12dB)
      // volumeFactor 0.0 -> -Infinity dB (silent)
      let targetVolume;
      if (volumeFactor <= 0.001) {
        // Essentially silent
        targetVolume = -100;
      } else {
        // Logarithmic scaling feels more natural for volume
        // Convert linear 0-1 to dB: 20 * log10(volumeFactor)
        const dbChange = 20 * Math.log10(volumeFactor);
        targetVolume = AUDIO_CONFIG.masterVolume + dbChange;
      }
      
      // Smooth volume transition
      Tone.getDestination().volume.rampTo(targetVolume, 0.1);
      
      // Debug log (uncomment if needed)
      // console.log(`Scroll volume: ${volumeFactor.toFixed(2)} -> ${targetVolume.toFixed(1)}dB`);
    }
  });

  // Keyboard controls for camera orientation
  window.addEventListener('keydown', (e: KeyboardEvent) => {
    keyState[e.key] = true;
  });

  window.addEventListener('keyup', (e: KeyboardEvent) => {
    keyState[e.key] = false;
  });

  // Reset rotation with spacebar (also reset velocities)
  window.addEventListener('keydown', (e: KeyboardEvent) => {
    if (e.key === ' ' || e.key === 'Spacebar') {
      cameraRotationX = 0;
      cameraRotationY = 0;
      rotationVelocityX = 0;
      rotationVelocityY = 0;
      e.preventDefault();
    }
  });
</script>
